\chapter{Implementation}
\paragraph{The Implementation of the project is written in Java on the integrated development environment IntelliJ. This IDE is one of the best options for coding because of the huge variety of benefits just like maven. This is a software management and build automation tool which is based on the concept of a project object modem (POM). One of the biggest feature in Maven is the dependency management. Maven automatically downloads in POM file declared libraries and plug-ins from a repository and stores them local. The local repository is a folder structure that is used as a centralized storage place for locally built artifacts and as a cache for downloaded dependencies. The Maven command mvn install builds a project and places its binaries in the local repository. Then other projects can utilize this project by specifying its coordinates in their POMs.}
\paragraph{The NoBeard GUI depends on some existing external package libraries. These libraries include a wide amount off packages. One of the most important package is the “machine”. This is defined as the core of the whole project because it has the most significantly parts including:}
\begin{itemize}
\item \textbf{NoBeardMachine: }a stack based machine with instructions defined as co-operator
\item \textbf{ControllUnit: }is responsible to execute commands and instructions
\item \textbf{DataMemory: }a byte addressed storage
\item \textbf{CallStack: }provide functions to add and remove frames from stack and maintains the expression stack
\item \textbf{InstructionSet: }a list of instructions and their implementations
\end{itemize}
\paragraph{The GUI is designed very similar to the Model-View-Controller pattern. However, this project is not depending on any database so it comes without any Model. The view is a single fxml file which holds the view components of the layout. It was created with an external tool called SceneBuilder that allows developers to design UI without any coding, just drag \& drop with the mouse. Every item of the view has an fx:id which is used in the controller to get easy access to the items. The controller is responsible for the coordination and operation of the view. Initially, it gets an instance of the NoBeard machine where simple program can be executed. The opening of a NoBeard object file is operated with the help of a BinaryFileHandler. After a successful opening of the object file, it has to be disassemble. This function converts binary files to primary program data where addresses, instructions and operands become visible on the UI.}
\paragraph{By finishing the translation, the machine has to load the string storage and the program from the object file. Program data is filled in a VBox with a CheckBox and text of the data for every line. All of the CheckBoxes gets an OnAction event which add and remove breakpoints from the machine.}
\paragraph{On starting a program, a new external thread has to be started where the machine runs separate from the UI. Its executes step by step every instruction of the program until any interruptions. It can be interrupted by a breakpoint, input request or by a halt instruction.}
\section{Interruption by breakpoint (Observer pattern)}
\paragraph{The implementation for the maintaining of breakpoints is coded with a simple observer pattern design to achieve the best performance of the virtual machine. The machine is completely separated from the breakpoint stuff. It runs only until its state equals to “running”. So, a new instruction is introduced, called “BREAK”, which sets the machine in to a “blocked” state. The ControlUnit class is going to be an Observable. Then a new Observer class is implemented which is called debugger that is holding all breakpoints in a HashMap. This HashMap stores the address and the instruction of a breakpoint. The debugger class contains in all three major functions. Adding, removing breakpoints to the HashMap and replacing an instruction at a specified address from the program memory to a new one. The selection of a breakpoint on the UI calls the set or remove function from the debugger, as the case may be. As soon as a breakpoint is selected, it will be stored to the HashMap with its original instruction and at same time replaces the original instruction by the newly added break instruction. This break instruction set the machine to a blocked state and notify the observer to change the break instruction back to the original one which is stored in the HashMap. Now the machine is blocked at a specified breakpoint and the user can take a look to the current stack frames and go one step further in the program or continue the execution cycle to a next breakpoint. However, when the user wants to step further to execute the current instruction where the breakpoint is, a switch back to the break instruction is needed again after the original instruction completed.}
\section{Interruption by input request (Threading)}
\paragraph{As already mentioned, the virtual machine runs on a separate thread so every time the user has to operate an input, a switch to the UI thread is needed. Otherwise it would cause a critical section between the threads. The synchronization of these two threads is implemented with the semaphore construction. The NoBeardMachine contains two interfaces to optimize outputs and inputs on the used device. As soon as the machine executes an input instruction (IN), it calls firstly a function from the input interface either hasNextInt() or hasNext(). Both do the same thing, checks whether there is an input by the user or not. The only different is that the one of them also checks if the string is numeric. These functions are overridden in the FxInputDevice class where also an instance of the controller is loaded by the constructor. So, by calling one of these hasNext function the machine thread should be paused. To avoid the deadlock, the semaphore from the controller is acquired at this position. Now the user can make an input on the FX thread and submit it. To get back to the machine thread, the semaphore hast to be released after the user fires the submit event by pressing the ENTER key. Then the machine continues at the same position where the semaphore was acquired, at one of the hasNext function and can analyse the provided input string.}