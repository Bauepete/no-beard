\documentclass[11pt]{report}
\usepackage{geometry}                % See geometry.pdf to learn the layout options. There are lots.
\geometry{a4paper}                   % ... or a4paper or a5paper or ... 
\usepackage{listings}
%\usepackage[parfill]{parskip}    % Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage[usenames, dvipsnames, table]{xcolor}
\usepackage{hyperref}

\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}

\newcommand{\leongage}{NoBeard}

\newcommand{\alternative}{$\mid \;$}
\newcommand{\emptystring}{$\varepsilon$}

% ---------------------------------------------- Definition of grammar environment -----------------------------------------------------
\newenvironment{grammar}
	{	\begin{tabular}{p{.25\textwidth} c p{.75\textwidth}}
	}
	{	\end{tabular}
	}
\newcommand{\completerule}[2]{#1 & = & #2.\\}
\newcommand{\startrule}[2]{#1 & = & #2\\}
\newcommand{\alternativerule}[1]{ & $|$ & #1\\}
\newcommand{\alternativeend}[1]{ & $|$ & #1.\\}
\newcommand{\finishrule}[1]{ & & #1.\\}

% ----------------------------------------------- Definition of attributed grammar environment
\newenvironment{atg}[1][6cm]
	{\begin{tabular}[b]{lclp{#1}}}
	{\end{tabular}}
\newcommand{\atgsy}[2]{$\textrm{#1}_\textrm{#2}$}
\newcommand{\outattr}{$\uparrow$}
\newcommand{\inattr}{$\downarrow$}

\newcommand{\semantics}[1]{\textcolor{Gray}{#1}}

\newenvironment {sem}
	{\underline{sem}}
	{\underline{endsem}}
	
\newcommand{\where}{\underline{where} }

% --------------------------------------------------- Definition of colors used in source code listings ----------------------------------------------
\definecolor{srcred}{rgb}{0.6,0,0}
\definecolor{srcpurple}{rgb}{0.5,0,0.35}
\definecolor{srcgreen}{rgb}{0.25,0.5,0.35}
\definecolor{srcblue}{rgb}{0.25,0.35,0.75}

% -------------------------------------------------- Definition of lstlisting for NoBeard ------------------------------------------------------------------
\lstdefinelanguage{NoBeard}{
	basicstyle=\ttfamily,
	frame=single,
	sensitive=true,
	morekeywords = {unit, function, do, done, int, char, put, putln},
	morecomment=[l][\color{srcgreen}]{\#},
	morestring=[b][\color{srcred}]{"},
	keywordstyle=\color{srcpurple},
	showspaces=false,
	showstringspaces=false
}

% --------------------------------- Definition of lstlisting for AsmDef the language to define assember commands -----------------------
\lstdefinelanguage{AsmDef}{
	basicstyle=\ttfamily,
	frame=single,
	sensitive=true,
	tabsize=3,
	morekeywords = {push, pop, printf, dat, prog, top, db, pc, ms},
	morecomment=[l][\color{srcgreen}]{//},
	morestring=[b][\color{srcred}]{"},
	keywordstyle=\color{srcpurple},
	showspaces=false,
	showstringspaces=false
}

% ------------------------------------------------------ Definition of assembler instruction commands --------------------------------------------
\newcommand{\onebyteinstruction}[1]{
\begin{tabular}{|p{3.9em}|}
\hline
\tiny{Byte 0} \\ \hline
#1  \\ \hline
\end{tabular}
}

\newcommand{\twobyteinstruction}[2]{
\begin{tabular}{|p{3.9em}|p{9em}|p{9em}|}
\hline
\tiny{Byte 0} & \tiny{Byte 1} \\ \hline
#1 & #2 \\ \hline
\end{tabular}
}

\newcommand{\threebyteinstruction}[2]{
\begin{tabular}{|p{3.9em}|p{9em}|p{9em}|}
\hline
\tiny{Byte 0} & \tiny{Byte 1} & \tiny{Byte 2} \\ \hline
#1 & \multicolumn{2}{c |}{#2} \\ \hline
\end{tabular}
}

\newcommand{\fourbyteinstructiona}[3]{
\begin{tabular}{|p{3.9em}|p{9em}|p{9em}|p{9em}|}
\hline
\tiny{0} & \tiny{1} & \tiny{2} & \tiny{3} \\ \hline
#1 & #2 & \multicolumn{2}{c |}{#3} \\ \hline
\end{tabular}
}

% ---------------------------------------------------------------------- Start of document -----------------------------------------------------------------
\begin{document}
\begin{titlepage}
\begin{center}
\includegraphics[scale=0.3]{no_beard_1.jpg} \\[2em]
{\Huge A Formal Description of \leongage} \\[1em]
{\large v 1.2} \\[2em]
{\Large P. Bauer} \\[1em]
HTBLA Leonding \\
Limesstr. 14 - 18 \\
4060 Leonding \\
Austria
\end{center}
\end{titlepage}

\section*{Revisions}
\begin{tabular}{|l|l|p{.5\textwidth}|}
\hline
\cellcolor{Gray}\textcolor{White}{Date} & \cellcolor{Gray}\textcolor{White}{Author} & \cellcolor{Gray}\textcolor{White}{Change} \\ \hline
June 25, 2016 & P. Bauer & Added more detailed description of the machine and added all assembler instructions used so far.  \\ \hline
June 12, 2016 & P. Bauer & Changed environment for grammar and formatting of source code. \\ \hline
June 5, 2014 & P. Bauer & {\bf Released v. 1.1}  \\ \hline
June 5, 2012 & P. Bauer & {\bf Released v. 1.0}  \\ \hline
\end{tabular}

\pagebreak

\tableofcontents
\chapter{Introduction}
According to a web article (see \cite{khason_computer_2008}) the popularity of programming languages is strongly related to the fact whether its inventor(s) is/are are bearded m[ae]n or not. Well, the main aim of the programming language \leongage{} is not to be popular,
moreover it should give the reader a clear insight how the main principles of compiler construction are.

This report aims to give a formal description of the programming language \leongage. Please note that only the parts
necessary for your work can be trusted. In the next versions, more and more information relevant for your assignments
will be available.

In case of typos, misleading wording or other problems, please feel free to contact me. Thanks for your help. Some more text to read~\cite{terry_compiling_2004}. 

\chapter{The Programming Language}
\section{Lexical Structure}

\leongage{} programs are written in text files of free format, i.e., there is no restriction concerning columns or lines where
the source text has to be. In this section the scanner relevant terms for \leongage{} are denoted in the form of regular expressions
with the extension that we allow "definitions" of non-terminals. This means in particular that if we define a term (e.g.
{\em letter} as it can be seen in the next section) this term can be used in subsequent definitions and is rewritten as
given in its original definition.

\subsection{Character Sets}
\begin{description}
	\item[letter] \texttt{'[A-Za-z]'}
	\item[digit]\texttt{'[0-9]'}
\end{description}

\subsection{Keywords}
There is only one keyword, namely \texttt{PUT}.

\subsection{Token Classes}
\begin{description}
	\item[ident] \texttt{['letter(letter \alternative digit)*']}
	\item[number] \texttt{['digit digit*]}
\end{description}

\subsection{Single Tokens}
The characters "{\tt+}", "{\tt-}", "{\tt*}", "{\tt/}", "{\tt:=}", "{\tt;}", "{\tt(}", and "{\tt)}" are mapped to single tokens.

\subsection{Semantics}
\begin{itemize}
	\item \leongage{} is a case sensitive language. For example, the names "myVar", "myvar", and "MYVAR" denote three different identifiers.
	\item Constants may only be between 0 and 65535 ($2^{16} - 1$).
	\item No symbol may span over more than one line.
\end{itemize}

\section{Sample Program}
\lstset{language=NoBeard}

\begin{lstlisting}
unit ComplexExpr;
# ----------------- ComplexExpr.nb ----------------------
# --- A syntactically correct NoBeard program
# -------------------------------------------------------
do
    int l = 10;
    int b =5;
    int h= 170;
        int unused = l;
    int x=1001 + l * b - h / (b * h);

    put ("Evaluating 1001 + l * b - h / (b * h)");
    putln;
    put ("Result is ");
    put (x);          # result should be 1051
done ComplexExpr;
\end{lstlisting}

\section{Syntax}
The following context free grammar gives the syntax of \leongage{}. The well-known EBNF notation~\cite{wirth_what_1977} is used.

	\begin{grammar}
		\completerule{NoBeard}{``unit'' identifier ``;'' Block identifier ``;''}
%	NoBeard & = & ``unit" ident ``;" Block ident ``;".\\

		\completerule{Block}{``do'' StatementSequence ``done''}
%	Block & = &  ``do" StatSeq ``done".\\

		\completerule{StatementSequence}{\{Statement\}}
		\\
%	StatSeq & = & Stat \{Stat\}. \\

		\startrule{Statement}{VariableDeclaration}
		\alternativerule{Put}
		\alternativerule{If}
		\alternativerule{Assignment}
		\alternativeend{\emptystring}
		\\
		\completerule{VariableDeclaration}{Type identifier [``='' Expression]``;''}
		\completerule{Type}{SimpleType[ArraySpecification]}
		\completerule{SimpleType}{``int'' $|$ ``char'' $|$ ``bool''}
		\completerule{ArraySpecification}{``['' number ``]''}
		\\
		\startrule{Put}{``put'' ``('' Expression \{``,'' Expression\} ``)''``;''}
		\alternativeend{``putln'' ``;''}
		\\
		\completerule{If}{``if'' Expression Block [ ``else'' Block ]}
		\\
		\completerule{Assignment}{Reference ``='' Expression ``;''}
		\completerule{Reference}{Identifier [ ``['' Expression``]'']}
		\\
		\completerule{Expression}{AddExpression [RelOp AddExpression]}
		\completerule{AddExpression}{[AddOp] Term \{AddOp Term\}}
		\completerule{Term}{Factor \{MulOp Factor\}}
		\completerule{Factor}{Reference $|$ number $|$ string $|$ ``('' Expression ``)''}
		\\
		\completerule{RelOp}{``$<$'' $|$ ``$<$='' $|$ ``=='' $|$ ``$>$='' $|$ ``$>$''}
		\completerule{AddOp}{``+'' $|$ ``-''}
		\completerule{MulOp}{``*'' $|$ ``/'' $|$ ``\%''}	
	\end{grammar}

\chapter{The \leongage{} Machine}
\lstset{language=AsmDef}
\section{Overview}
The virtual machine being target for \leongage{} programs is a stack machine with instructions of variable length and has the following components. The word width of the \leongage{} machine is 4 bytes.

\begin{tabular}{p{.2\textwidth}p{.71\textwidth}}
	\lstinline$prog[MAX_PROG]$ & The {\em program memory} which is byte addressed. \\
	
	\lstinline$dat[MAX_DATA]$] & The {\em data memory} is byte addressed and is separated into two parts:
	\begin{itemize}
		\item String constants
		\item Stack frames of the currently running functions
	\end{itemize}
	Figure~\ref{fig:datamemory} shows this. Before a program is started the string constants are stored in constant memory. On top of this the stack frames are maintained as follows: Every time a function is called a frame is added. It holds data for the function arguments, local variables, some auxiliary data and its expression stack (shortly called stack in the sequel). As soon as the function ends, its frame is removed. A more detailed description of stack frames is given in section~\ref{sec:stackframes}.
	
	The expression stack is used to store data needed for each statement. It grows and shrinks as needed and is empty at the end of each statement. The stack is addressed word-wise only. The functions \lstinline$push()$ and \lstinline$pop()$ are used to add and remove values to and from the stack, respectively. \\
	
	\lstinline$top$ & Address of the start of the last used word on the stack. \\
	\lstinline$db$ & {\em Data Base}: Address of the first byte of the currently running function's stack frame. \\
	\lstinline$pc$ & {\em Program Counter}: Start address of the next instruction in \lstinline$prog$ to be executed.\\
	\lstinline$ms$ & {\em Machine State}: The \leongage{} machine may have three different states:
	\begin{itemize}
		\item \lstinline$run$: The machine runs
		\item \lstinline$stop$: The machine stops. Usually when the end of program is reached.
		\item \lstinline$error$: Error state
	\end{itemize}
\end{tabular}

\begin{figure}\label{fig:datamemory}
\begin{center}
\begin{tabular}{p{8em}|p{8em}|}
\cline{2-2}
\parbox[t][3em][t]{8em}{\hfill 0} & String Constants \\[3em] \cline{2-2}
& Stack frame 1 \\[2em] \cline{2-2}
& Stack frame 2 \\[2em] \cline{2-2}
& \ldots \\[2em] \cline{2-2}
\parbox[b][4em][b]{8em}{\hfill MAX\_DATA} & free \\ \cline{2-2}
\end{tabular}
\end{center}
\caption{Data Memory of the \leongage{} Machine}
\end{figure}

\section{Stack Frames}\label{sec:stackframes}

\section{Runtime Structure of a \leongage{} Program}
The \leongage{} Machine follows the following fixed execution cycle:
\begin{enumerate}
	\item Fetch instruction
	\item Decode instruction
	\item Execute instruction
\end{enumerate}
The very first instruction is fetched from {\tt prog[startPc]} where {\tt startPc} has to be provided as an argument when starting the program. From this point of time onwards the program is executed until the machine state changes from {\em run}.

\begin{lstlisting}
runProg(startPc) {
	db = start byte of first free word in dat;
	top = db + 28;
	pc = startPc;
	ms = run;
	
	while (ms == run) {
		fetch instruction which starts at prog[pc];
		pc = pc + length of instruction;
		execute instruction
	}
}
\end{lstlisting}

\section{Instructions}
\leongage{} instructions have a variable length. Every instruction has one opcode and either zero, or one, or two operands. When describing the instructions we use the following conventions:

Each instruction is described in one of the following subsections. The title of the subsection is the mnemonic by which the instruction is identified on assembler level. Then a table follows which shows the size of the instruction and which bytes carry which information. For all instructions the first byte is dedicated to the op code, which is the id by which the instruction is identified on machine language level.

The remaining bytes, if any, are dedicated to the operands of the instruction. When describing these we use the following conventions:

\begin{tabular}{llcp{18.8em}}
Name & Range & Size & Description \\
Literal & 0 ... 65535 & 2 Bytes & Unsigned integer number. \\
Displacement & 0 ... 256 & 1 Byte & Static difference in hierarchy between declaration and usage of an object. \\
DataAddress & 0 ... 65535 & 2 Bytes & Data address relative to the start of its stack frame.
\end{tabular}

Each of these subsections ends with a description of its operation: First a description in human language is given which is then followed by a formal definition.

% ----------------------------- NOP ----------------------------
\subsection{NOP}
\subsubsection{Instruction}
\onebyteinstruction{0x00}

\subsubsection{Operation}
Empty instruction. Does nothing

\begin{lstlisting}
NOP
\end{lstlisting}

% ----------------------------- LIT ----------------------------
\subsection{LIT}
\subsubsection{Instruction}
\threebyteinstruction{0x01}{Literal}

\subsubsection{Operation}
Pushes a value on the expression stack.

\begin{lstlisting}
LIT Literal
push(Literal);
\end{lstlisting}

% ----------------------------- LA ----------------------------
\subsection{LA}
\subsubsection{Instruction}
\fourbyteinstructiona{0x02}{Displacement}{DataAddress}

\subsubsection{Operation}
Loads an address on the stack.

	\begin{lstlisting}
	LA Displacement DataAddress
	base = db;
	for (i= 0; i < Displacement; i++) {
		base = dat[base ... base + 3];
	}
	push(base + DataAddress);
	\end{lstlisting}

% ----------------------------- LV ----------------------------
\subsection{LV}
\subsubsection{Instruction}
\fourbyteinstructiona{0x03}{Displacement}{DataAddress}

\subsubsection{Operation}
Loads a value on the stack.

	\begin{lstlisting}
	LV Displacement DataAddress
	base = db;
	for (i = 0; i < Displacement; i++) {
		base = dat[base ... base + 3];
	}
	adr = base + DataAddress;
	push(dat[addr ... addr + 3]);
	\end{lstlisting}

% ----------------------------- LC ----------------------------
\subsection{LC}
\subsubsection{Instruction}
\fourbyteinstructiona{0x04}{Displacement}{DataAddress}

\subsubsection{Operation}
Loads a character on the stack.

	\begin{lstlisting}
	LC Displacement DataAddress
	base = db;
	for (i = 0; i < Displacement; i++) {
		base = dat[base ... base + 3];
	}
	// fill 3 bytes of zeros to get a full word
	lw = 000dat[base + Address];
	push(lw);
	\end{lstlisting}

% ----------------------------- STO ----------------------------
\subsection{STO}
\subsubsection{Instruction}
\onebyteinstruction{0x07}

\subsubsection{Operation}
Stores a value on an address.

	\begin{lstlisting}
	STO
	x = pop();
	a = pop();
	dat[a ... a + 3] = x;
	\end{lstlisting}

% ----------------------------- STC ----------------------------
\subsection{STC}
\subsubsection{Instruction}
\onebyteinstruction{0x08}

\subsubsection{Operation}
Stores a character on an address.

	\begin{lstlisting}
	STC
	x = pop();
	a = pop();
	// Only take the rightmost byte
	dat[a] = 000x;
	\end{lstlisting}

% ----------------------------- ASSN ----------------------------
\subsection{ASSN}
\subsubsection{Instruction}
\onebyteinstruction{0x0A}

\subsubsection{Operation}
Array assignment.

	\begin{lstlisting}
	ASSN
	n = pop();
	src = pop();
	dest = pop();
	for (i = 0; i < n; i++)
	   dat[dest + i] = dat[src + i];
	\end{lstlisting}

% ----------------------------- NEG ----------------------------
\subsection{NEG}
\subsubsection{Instruction}
\onebyteinstruction{0x0B}

\subsubsection{Operation}
Negates the top of the stack.

	\begin{lstlisting}
	NEG
	x = pop();
	push(-x);
	\end{lstlisting}

% ----------------------------- ADD ----------------------------
\subsection{ADD}
\subsubsection{Instruction}
\onebyteinstruction{0x0C}

\subsubsection{Operation}
Adds the top two values of the stack.

	\begin{lstlisting}
	ADD
	push(pop() + pop());
	\end{lstlisting}

% ----------------------------- SUB ----------------------------
\subsection{SUB}
\subsubsection{Instruction}
\onebyteinstruction{0x0D}

\subsubsection{Operation}
Subtracts the top two values of the stack.

	\begin{lstlisting}
	SUB
	y = pop();
	x = pop();
	push(x - y);
	\end{lstlisting}

% ----------------------------- MUL ----------------------------
\subsection{MUL}
\subsubsection{Instruction}
\onebyteinstruction{0x0E}

\subsubsection{Operation}
Multiplies the top two values of the stack.

	\begin{lstlisting}
	MUL
	push(pop() * pop());
	\end{lstlisting}

% ----------------------------- DIV ----------------------------
\subsection{DIV}
\subsubsection{Instruction}
\onebyteinstruction{0x0F}

\subsubsection{Operation}
Divides the top two values of the stack.

	\begin{lstlisting}
	DIV
	y = pop();
	x = pop();
	push(x / y);
	\end{lstlisting}

% ----------------------------- MOD ----------------------------
\subsection{MOD}
\subsubsection{Instruction}
\onebyteinstruction{0x10}

\subsubsection{Operation}
Calculates the remainder of the division of the top values of the stack.

	\begin{lstlisting}
	MOD
	y = pop();
	x = pop();
	push(x % y);
	\end{lstlisting}

% ----------------------------- NOT ----------------------------
\subsection{NOT}
\subsubsection{Instruction}
\onebyteinstruction{0x11}

\subsubsection{Operation}
Calculates the remainder of the division of the top values of the stack.

	\begin{lstlisting}
	NOT
	x = pop();
	if (x == 0)
	   push(1);
	else
	   push(0);
	\end{lstlisting}

% ----------------------------- REL ----------------------------
\subsection{REL}
\subsubsection{Instruction}
\twobyteinstruction{0x12}{RelOp}

\subsubsection{Operation}
Compares two values of the stack and pushes the result back on the stack. The operand \lstinline$RelOp$ can have six different values:
\begin{itemize}
	\item 0 for encoding $<$ (smaller than)
	\item 1 for encoding $<=$ (smaller or equal than)
	\item 2 for encoding == (equals)
	\item 3 for encoding != (not equals)
	\item 4 for encoding $>=$ (greater or equal than)
	\item 0 for encoding $>$ (greater than)
\end{itemize}
	\begin{lstlisting}
	REL RelOp
	y = pop();
	x = pop();
	switch(RelOp) {
		case 0:
			if (x < y) push(1); else push(0);
			break;
		case 1:
			if (x <= y) push(1); else push(0);
			break;
		case 2:
			if (x == y) push(1); else push(0);
			break;
		case 3:
			if (x != y) push(1); else push(0);
			break;
		case 4:
			if (x >= y) push(1); else push(0);
			break;
		case 5:
			if (x > y) push(1); else push(0);
			break;
	}
	\end{lstlisting}

% ----------------------------- FJMP ----------------------------
\subsection{FJMP}
\subsubsection{Instruction}
\threebyteinstruction{0x16}{NewPc}

\subsubsection{Operation}
Sets \lstinline$pc$ to \lstinline$newPc$ if stack top value is false.

	\begin{lstlisting}
	FJMP newPc
	x = pop();
	if (x == 0)
	   pc = NewPc;
	\end{lstlisting}

% ----------------------------- TJMP ----------------------------
\subsection{TJMP}
\subsubsection{Instruction}
\threebyteinstruction{0x17}{NewPc}

\subsubsection{Operation}
Sets \lstinline$pc$ to \lstinline$newPc$ if stack top value is true.

	\begin{lstlisting}
	TJMP newPc
	x = pop();
	if (x == 1)
	   pc = NewPc;
	\end{lstlisting}

% ----------------------------- JMP ----------------------------
\subsection{JMP}
\subsubsection{Instruction}
\threebyteinstruction{0x18}{NewPc}

\subsubsection{Operation}
Unconditional jump: Sets \lstinline$pc$ to \lstinline$newPc$.

	\begin{lstlisting}
	JMP newPc
	pc = NewPc;
	\end{lstlisting}

% ----------------------------- PUT ----------------------------
\subsection{PUT}
\subsubsection{Instruction}
\twobyteinstruction{0x1A}{Type}

\subsubsection{Operation}
Writes data to the terminal. Depending on \lstinline$Type$ different data types are printed:

\begin{itemize}
	\item 0: An \lstinline$int$ with a specific column width is printed
	\item 1: A \lstinline$char$ with a specific column width is printed
	\item 2: a \lstinline$string$ with a specific column width is printed
	\item 3: a new line is printed
\end{itemize}

	\begin{lstlisting}
	PUT Type
	switch(Type) {
		case 0:
			width = pop();
			x = pop();
			// + means string concatenation in the next line
			formatString = "%" + width + "d";
			printf(formatString, x);
			break;
		case 1:
			width= pop();
			x = pop();
			printf("%c", x);
			for (i = 0; i < width - 1; i++)
				printf(" ");
			break;
		case 2:
			width = pop();
			strLen = pop();
			strAddr = pop();
			printf("%s", dat[strAddr ... strAddr + strLen - 1]);
			for (i = n; i < width - 1; i++)
				printf(" ");
			break;
		case 3:
			printf("\n");
			break;
	}
	\end{lstlisting}

% ----------------------------- INC ----------------------------
\subsection{INC}
\subsubsection{Instruction}
\threebyteinstruction{0x1D}{Size}

\subsubsection{Operation}
Increases the size of the stack frame by \lstinline$Size$.

	\begin{lstlisting}
	INC Size
	top += Size;
	\end{lstlisting}

% ----------------------------- HALT ----------------------------
\subsection{HALT}
\subsubsection{Instruction}
\onebyteinstruction{0x1F}

\subsubsection{Operation}
Halts the machine.

	\begin{lstlisting}
	HALT
	ms = stop;
	\end{lstlisting}

\chapter{Symbol List}

\lstset{language=NoBeard,
	numbers=left,
	tabsize=2
}
\begin{lstlisting}
unit M;
	function A(int a);
		int b;
		
		int function B(char c);
			int d;
		do
				# some code
		done B;
		
		char function C;
			int e;
		do
			# some more code
		done C;
	do
		# some code on A
	done A;
do
	# this is the main of unit M
done M;
\end{lstlisting}

After parsing line 1 the symbol list looks as follows:

\begin{tabular}{lllrrr}
name & kind & type & size & addr & level \\
\hline
M & PROCKIND & UNITTYPE & 0 & 0 & 0
\end{tabular}

After parsing line 2 a snapshot on the symbol list looks like

\begin{tabular}{lllrrr}
name & kind & type & size & addr & level \\
\hline
M & PROCKIND & UNITTYPE & 0 & 0 & 0 \\
A & PROCKIND & UNITTYPE & 0 & 0 & 1 \\
a & PARKIND & SIMINT & 4 & 32 & 2
\end{tabular}

After parsing line 3

\begin{tabular}{lllrrr}
name & kind & type & size & addr & level \\
\hline
M & PROCKIND & UNITTYPE & 0 & 0 & 0 \\
A & PROCKIND & PROCTYPE & 4 & 0 & 1 \\
a & PARKIND & SIMINT & 4 & 32 & 2 \\
b & VARKIND & SIMINT & 4 & 36 & 2
\end{tabular}

After parsing line 6 being somewhere between line 7 and the end of line 9.

\begin{tabular}{lllrrr}
name & kind & type & size & addr & level \\
\hline
M & PROCKIND & UNITTYPE & 0 & 0 & 0 \\
A & PROCKIND & PROCTYPE & 4 & 0 & 1 \\
a & PARKIND & SIMINT & 4 & 32 & 2 \\
b & VARKIND & SIMINT & 4 & 36 & 2 \\
B & PROCKIND & PROCTYPE & 0 & 0 & 2 \\
c & PARKIND & SIMCHAR & 1 & 32 & 3 \\
d & VARKIND & SIMINT & 4 & 36 & 3
\end{tabular}



\chapter{Some Translations by Example}
\section{Reserving Space for Local Variables}

\section{Assignments}

\section{Boolean Expressions}
We show the translation of a boolean expression {\tt a $\mid \mid$ b $\mid \mid$ c} where {\tt a}, {\tt b}, and {\tt c} are variables of type {\tt bool}. The sequence of several relational expressions or boolean variables connected via a boolean {\em or} is realized by a so-called or-chain. In particular, after evaluation of each single relational expression (or boolean variable) and this evaluation yields {\em true} all further evaluations are skipped and the program flow is continued at the end of the complete boolean expression. Figure~\ref{fig:orchain} shows this principle. In order to keep the program flow simple, the load value parts in front of each evaluation are skipped. The more detailed \leongage{} assembler code for this sequence is given in listing~\ref{cod:orchain}. Note that, for the sake of simplicity, the addresses given as operands to the {\tt JMP} and {\tt TJMP} instructions are the line numbers here. Of course, the ``real" code generates the memory addresses of the targeted assembler instruction.

\begin{figure}
\begin{center}
\includegraphics[scale=.5]{images/OrChain.png}
\end{center}
\caption{Program flow of an or chain}
\label{fig:orchain}
\end{figure}

\lstset{language=[x86masm]Assembler, morekeywords={LV,TJMP,LIT}}

\begin{lstlisting}[float,caption={Assembler code of or-chain}, captionpos=b,label=cod:orchain]
...
LV 0, 32		; load value a
TJMP 8			; if true, jump to the end
LV 0, 36		; load value b
TJMP 8			; if true, jump to the end
LV 0, 40		; load value c
JMP 9				; result is determined by c only
LIT 1
...
\end{lstlisting}
When generating this kind of code, we have to deal with the situation that the final addresses we have to jump to are not known in prior. Therefore, we have to construct a so-called or-chain, which work as follows. While parsing a conditional expression, we maintain an int variable holding the 

The translation of {\em and-}expressions works analogously.

%\section{Jumps in If- and While-Statements}

\chapter{Error Handling}
ErrorHandler.getInstance().raise(new ...));

\chapter{Attributed Grammar}
\begin{atg}[4.5cm]
\leongage &=& & \semantics{\begin{sem} \newline EmitOp(INC); \newline Emit2(0); \newline int inc\_addr = 1; \newline \end{sem}}\\
&&Stat ";" \{Stat ";"\}. \\

Stat & = & ident ":=" \atgsy{Expr}{\outattr op}  \alternative \\
&& "PUT" \atgsy{Expr}{\outattr op}. \\

\atgsy{Term}{\outattr op} &=& \atgsy{Fact}{\outattr op}  \\
&& \{("*" &\semantics{\begin{sem} opcode = mul \end{sem}}\\
&& \alternative "/" & \semantics{\begin{sem} opcode = div \end{sem}}\\
&&) & \semantics{\begin{sem}EmitOp(\inattr opcode)\end{sem}}\\
&&\atgsy{Fact}{\outattr op} & \semantics{\begin{sem}LoadVal(\inattr op)\end{sem}}
\end{atg}

\bibliography{my_bibliography}{}
\bibliographystyle{alphaurl} % save alternatives are abbrvurl	alphaurl	plainurl	unsrturl

\end{document}  